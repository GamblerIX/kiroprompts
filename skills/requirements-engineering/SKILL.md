---
name: requirements-engineering
description: 使用 EARS 格式将模糊的功能想法转化为清晰、可测试的需求。捕获用户故事，定义验收标准，识别边缘情况，并在进入设计阶段前验证完整性。
license: MIT
compatibility: Claude Code, Cursor, VS Code, Windsurf
metadata:
  category: methodology
  complexity: beginner
  author: Kiro Team
  version: "1.0.0"
---

# 需求工程 (Requirements Engineering)

掌握在深入构建之前明确“构建什么”的艺术。此技能教授 EARS（简单的需求语法方法）格式，用于创建清晰、可测试的需求。

## 何时使用此技能

在以下情况下使用需求工程：
- 开始任何新功能或项目时
- 澄清模糊的利益相关者请求时
- 为用户故事创建验收标准时
- 为测试记录系统行为时
- 确保所有团队成员共享理解时

## EARS 格式

EARS 提供了编写具体、可测试且无歧义需求的一致模式。

### 基础模式

**事件-响应（最常见）：**
```
当 [触发事件] 时 [系统] 应 [要求的响应]
```

**条件行为：**
```
如果 [满足前置条件] 则 [系统] 应 [要求的响应]
```

**复杂条件：**
```
当 [事件] 且 [附加条件] 时 [系统] 应 [响应]
```

**可选条件：**
```
当 [事件] 或 [替代事件] 时 [系统] 应 [响应]
```

### 高级模式

**基于状态：**
```
当 [系统处于特定状态] 时 [系统] 应 [行为]
```

**性能：**
```
当 [用户操作] 时 [系统] 应 [在 X 秒/毫秒内响应]
```

**安全：**
```
如果 [认证条件] 则 [系统] 应 [安全响应]
```

## 分步流程

### 第一步：捕获用户故事

格式：**作为一个 [角色]，我想要 [功能]，以便 [好处]**

关注：
- 谁是用户？（角色）
- 他们想要完成什么？（功能）
- 为什么这很重要？（好处/价值）

**示例：**
```markdown
作为一个回头客，我想要保存我的支付方式，以便我将来可以更快地结账。
```

### 第二步：生成验收标准

对于每个用户故事，使用 EARS 定义具体的验收标准：

**支付方式示例：**
```markdown
**用户故事：** 作为一个回头客，我想要保存我的支付方式，以便我可以更快地结账。

**验收标准：**
1. 当用户添加一张有效的信用卡时，系统应安全存储卡详情
2. 当用户添加一张号码无效的卡时，系统应显示验证错误
3. 当用户拥有已保存的卡时，系统应在结账时显示列表
4. 当用户选择已保存的卡时，系统应预填充支付表单
5. 当用户删除已保存的卡时，系统应从列表中移除该卡
6. 如果用户未通过身份验证，则系统应在保存卡之前重定向到登录
7. 当用户添加卡时，系统应在显示中屏蔽除最后 4 位以外的所有数字
```

### 第三步：识别边缘情况

对于每个需求，问：
- 如果输入为空/null 怎么办？
- 如果输入处于边界值怎么办？
- 如果操作失败怎么办？
- 如果用户未获授权怎么办？
- 如果存在并发操作怎么办？

**边缘情况模式：**
```markdown
**错误处理：**
- 当 [操作失败] 时系统应 [显示错误 / 重试 / 记录日志]

**边界条件：**
- 当 [值等于最小/最大] 时系统应 [特定行为]

**并发访问：**
- 当 [多个用户访问同一资源] 时系统应 [冲突解决]

**空状态：**
- 当 [集合为空] 时系统应 [显示空状态消息]
```

### 第四步：验证需求

使用此检查清单：

**完整性：**
- [ ] 所有用户角色都已识别并处理
- [ ] 正常流程场景已覆盖
- [ ] 边缘情况已记录
- [ ] 错误情况已处理
- [ ] 业务规则已捕获

**清晰度：**
- [ ] 每个需求都使用精确的语言
- [ ] 没有模棱两可的词语（快速、容易、用户友好）
- [ ] 避免或定义了技术术语
- [ ] 预期行为具体明确

**一致性：**
- [ ] 通篇使用 EARS 格式
- [ ] 跨需求术语一致
- [ ] 没有相互矛盾的需求
- [ ] 相似场景处理方式相似

**可测试性：**
- [ ] 每个需求都可验证
- [ ] 成功标准可观察
- [ ] 输入和预期输出已指定
- [ ] 性能需求可衡量

## 避免常见错误

### 错误 1：模糊的需求
**坏：** “系统应该很快”
**好：** “当用户提交搜索时，系统应在 2 秒内返回结果”

### 错误 2：实施细节
**坏：** “系统应使用 Redis 进行缓存”
**好：** “当用户请求频繁访问的数据时，系统应返回缓存结果”

### 错误 3：缺少错误案例
**坏：** 仅记录快乐路径
**好：** 为所有错误条件包含 当/如果 语句

### 错误 4：不可测试的需求
**坏：** “系统应该用户友好”
**好：** “当新用户完成入职培训时，系统应要求不超过 3 次点击即可到达主仪表板”

### 错误 5：冲突的需求
**坏：** 彼此矛盾的需求
**好：** 一起审查所有需求，明确解决冲突

## 示例

### 示例 1：文件上传功能

```markdown
**用户故事：** 作为一个用户，我想要上传文件，以便我可以与我的团队共享文档。

**验收标准：**
1. 当用户选择小于 10MB 的文件时，系统应接受文件上传
2. 当用户选择超过 10MB 的文件时，系统应显示“文件太大（最大 10MB）”错误
3. 当用户选择不支持的文件类型时，系统应显示“不支持的格式”错误及允许的类型列表
4. 当上传正在进行时，系统应显示带有百分比的进度指示器
5. 当上传成功完成时，系统应显示成功消息及文件链接
6. 当由于网络错误导致上传失败时，系统应显示重试选项
7. 如果用户未通过身份验证，则系统应在上传之前重定向到登录
8. 当用户上传与现有文件同名的文件时，系统应提示重命名或替换

**支持的文件类型：** PDF, DOC, DOCX, XLS, XLSX, PNG, JPG, GIF
**最大文件大小：** 10MB
**每次上传最大文件数：** 5
```

### 示例 2：搜索功能

```markdown
**用户故事：** 作为一个客户，我想要搜索产品，以便我可以快速找到商品。

**验收标准：**
1. 当用户输入搜索词时，系统应显示匹配的产品
2. 当搜索返回结果时，系统应显示结果数量
3. 当搜索未返回结果时，系统应显示“未找到产品”及建议
4. 当用户使用特殊字符搜索时，系统应清理输入并进行搜索
5. 当用户提交空搜索时，系统应显示验证消息
6. 当结果超过 20 项时，系统应分页，每页 20 项
7. 当用户搜索时，系统应在 2 秒内返回结果
8. 当用户在搜索框中键入时，系统应在 3 个字符后显示自动完成建议

**搜索字段：** 产品名称，描述，类别，SKU
**最小搜索长度：** 2 个字符
```

## 需求文档模板

```markdown
# 需求文档：[功能名称]

## 概述
[功能及其目的简要描述]

## 用户角色
- [角色 1]：[此用户类型的描述]
- [角色 2]：[此用户类型的描述]

## 需求

### 需求 1：[名称]
**用户故事：** 作为一个 [角色]，我想要 [功能]，以便 [好处]

**验收标准：**
1. 当 [事件] 时系统应 [响应]
2. 如果 [条件] 则系统应 [响应]
3. 当 [事件] 且 [条件] 时系统应 [响应]

**边缘情况：**
- [边缘情况 1 及其处理方式]
- [边缘情况 2 及其处理方式]

### 需求 2：[名称]
[继续模式...]

## 非功能性需求
- **性能：** [具体指标]
- **安全：** [安全需求]
- **无障碍：** [无障碍标准]

## 范围外
- [此功能中明确不包含的项目]

## 待解决问题
- [需要利益相关者输入的问题]
```

## 下一步

完成需求后：
1. 与利益相关者一起审查准确性
2. 在继续之前获得明确批准
3. 进入设计阶段以创建技术架构
4. 使用需求作为验收测试的基础
