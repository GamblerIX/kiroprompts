---
name: spec-driven-development
description: 系统的三阶段功能开发方法，使用需求、设计和任务阶段。将模糊的功能想法转化为定义明确、可实施的解决方案，从而减少歧义，提高质量，并实现有效的 AI 协作。
license: MIT
compatibility: Claude Code, Cursor, VS Code, Windsurf
metadata:
  category: methodology
  complexity: intermediate
  author: Kiro Team
  version: "1.0.0"
---

# 规范驱动开发 (Spec-Driven Development)

一种用于系统化软件功能开发的综合方法论，通过结构化规划确保质量、可维护性和成功交付。

## 何时使用此技能

**理想场景：**
- 具有多个组件、集成或用户交互的复杂功能
- 返工成本高昂的高风险项目
- 需要共识的团队协作
- 清晰结构能提高输出质量的 AI 辅助开发
- 为未来的维护者保留知识

**不太适合：**
- 解决方案显而易见的简单错误修复
- 用于快速迭代的实验性原型
- 需要立即采取行动的时间紧迫的热修复
- 极少歧义的成熟模式

## 三阶段工作流

### 第一阶段：需求收集

**目的：** 将模糊的功能想法转化为清晰、可测试的需求

**流程：**
1. 捕获表达价值和目的的用户故事
2. 使用 EARS 格式（简单的需求语法方法）定义验收标准
3. 识别边缘情况和约束
4. 验证完整性和可行性

**EARS 格式模式：**
```
当 [事件] 时 [系统] 应 [响应]
如果 [前置条件] 则 [系统] 应 [响应]
当 [事件] 且 [条件] 时 [系统] 应 [响应]
```

**示例：**
```markdown
**用户故事：** 作为一个新用户，我想要创建一个账户，以便我可以访问个性化功能。

**验收标准：**
1. 当用户提供有效的电子邮件和密码时，系统应创建新账户
2. 当用户提供现有的电子邮件时，系统应显示“电子邮件已注册”错误
3. 当用户提供短于 8 个字符的密码时，系统应显示“密码太短”错误
4. 当账户创建成功时，系统应发送确认电子邮件
```

### 第二阶段：设计文档

**目的：** 创建全面的实施技术计划

**流程：**
1. 研究技术方法和约束
2. 定义系统架构和组件交互
3. 指定数据模型和接口
4. 规划错误处理和测试策略

**设计文档结构：**
```markdown
## 概述
[方法的高层总结]

## 架构
[系统组件及其关系]

## 组件与接口
[详细的组件描述]

## 数据模型
[数据结构和验证规则]

## 错误处理
[错误场景和响应策略]

## 测试策略
[不同层级的测试方法]
```

**决策文档：**
```markdown
### 决策：[标题]
**背景：** [需要做出决策的情况]
**考虑的选项：**
1. [选项 1] - 优点：[好处] / 缺点：[坏处]
2. [选项 2] - 优点：[好处] / 缺点：[坏处]
**决策：** [选定的选项]
**理由：** [为什么选择这个]
```

### 第三阶段：任务规划

**目的：** 将设计分解为可操作的、顺序的实施步骤

**流程：**
1. 将设计元素转换为具体的编码任务
2. 对任务进行排序以实现增量进展
3. 定义明确的目标和完成标准
4. 引用需求以实现可追溯性

**任务结构：**
```markdown
- [ ] 1. [史诗/主要组件]
- [ ] 1.1 [具体的实施任务]
  - [实施细节]
  - [要创建的文件/组件]
  - _需求：[需求引用]_
```

**任务排序策略：**
- **基础优先：** 在依赖组件之前先完成核心接口
- **功能切片：** 用于早期验证的端到端垂直切片
- **风险优先：** 及早处理不确定领域
- **混合：** 根据项目需求结合多种方法

## 质量检查清单

### 需求检查清单
- [ ] 所有用户角色都已识别并处理
- [ ] 正常、边缘和错误情况都已覆盖
- [ ] 需求是可测试和可衡量的
- [ ] 没有相互冲突的需求
- [ ] 一致使用 EARS 格式

### 设计检查清单
- [ ] 设计中解决了所有需求
- [ ] 组件职责定义明确
- [ ] 组件之间的接口已指定
- [ ] 错误处理覆盖了预期的故障
- [ ] 安全考虑已处理

### 任务检查清单
- [ ] 所有设计组件都有实施任务
- [ ] 任务排序尊重依赖关系
- [ ] 每个任务都产生可测试的代码
- [ ] 包含需求引用
- [ ] 范围适当（每个 2-4 小时）

## 与 AI 工作流集成

**对于 Claude Code / AI 助手：**

1. **从上下文开始：** 提供项目背景、约束和目标
2. **分阶段工作：** 在设计之前完成需求，在任务之前完成设计
3. **迭代：** 通过对话完善输出，而不是单次请求
4. **验证：** 要求 AI 根据检查清单审查输出
5. **追踪：** 保持需求、设计和任务之间的链接

**开始规范的示例提示：**
```
我正在处理 [项目上下文]。我们需要添加 [功能描述]。

上下文：
- 技术：[技术栈]
- 用户：[目标受众]
- 约束：[关键限制]

请帮助我使用 EARS 格式开发需求，从用户故事和验收标准开始。
```

## 常见陷阱避免

1. **跳过阶段：** 每个阶段都建立在主要阶段之上；走捷径会制造问题
2. **模糊的需求：** “系统应该很快” vs 具体、可衡量的标准
3. **需求中的实施细节：** 关注是什么，而不是怎么做
4. **过度设计：** 解决当前需求，而不是假设的未来需求
5. **单体任务：** 分解为 2-4 小时的增量
6. **缺少错误案例：** 始终考虑出错时会发生什么

## 下一步

在完成规范后：
1. 按照任务顺序开始实施
2. 通过标记任务完成来跟踪进度
3. 如果实施揭示了差距，更新规范
4. 根据需求验证完成的工作
5. 记录经验教训以供未来规范使用
