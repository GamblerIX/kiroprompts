# 需求阶段文档

<!-- 导航元数据 -->
<!-- 阶段：需求 | 级别：详细指南 | 前置条件：methodology/README.md -->
<!-- 相关：templates/requirements-template.md, resources/standards.md, examples/simple-feature-spec.md -->

**📍 你在这里：** [主指南](../../README.md) → [流程指南](README.md) → **需求阶段**

## 快速导航
- **🎯 开始：** [需求模板](../templates/requirements-template.md) - 即用型模板
- **📖 查看示例：** [简单功能规范](../examples/simple-feature-spec.md) - 完整需求示例
- **📚 学习 EARS：** [标准参考](../resources/standards.md) - EARS 格式详情
- **➡️ 下一阶段：** [设计阶段](design-phase.md) - 需求获批后

## 阶段导航
- **上一步：** [流程概述](README.md) - 三阶段工作流
- **当前：** **需求阶段** - 将创意转化为结构化需求
- **下一步：** [设计阶段](design-phase.md) - 创建技术架构
- **最后：** [任务阶段](tasks-phase.md) - 分解为实施步骤

---

## 概述

需求阶段是规范驱动开发的基础，也就是将粗略的功能想法转化为清晰、可测试的需求，这里使用 EARS（需求语法简便方法）格式。该阶段确保所有利益相关者在通过设计和实施之前对需构建内容达成共识。

## 目的和目标

需求阶段旨在：
- 将模糊的功能想法转化为具体、可衡量的需求
- 为功能成功建立明确的验收标准
- 在利益相关者之间建立共同理解
- 为设计和实施决策提供基础
- 启用有效的测试和验证策略

## 分步流程

### 第一步：初始需求生成

**目标**：基于功能想法创建需求的初稿

**流程**：
1. **分析功能想法**：将核心概念分解为面向用户的功能
2. **识别用户角色**：确定谁将与功能交互
3. **定义用户故事**：创建格式为"作为[角色]，我想要[功能]，以便[益处]"的用户故事
4. **生成验收标准**：为每个用户故事编写 EARS 格式的需求

**关键原则**：
- 从用户体验开始，而非技术实施
- 专注于可观察、可测试的行为
- 考虑边缘情况和错误场景
- 思考完整的用户旅程

### 第二步：需求结构和格式

**文档结构**：
```markdown
# 需求文档

## 简介
[功能的简要概述及其目的]

## 需求

### 需求 1
**用户故事：** 作为[角色]，我想要[功能]，以便[益处]

#### 验收标准
1. WHEN [事件] THEN [系统] SHALL [响应]
2. IF [前置条件] THEN [系统] SHALL [响应]
3. WHEN [事件] AND [条件] THEN [系统] SHALL [响应]

### 需求 2
[继续其它需求...]
```

**EARS 格式指南**：
- **WHEN**：描述触发事件或条件
- **IF**：描述必须满足的前置条件
- **THEN**：描述系统的必要响应
- **SHALL**：指示强制行为（始终使用）
- **AND/OR**：必要时组合条件

### 第三步：需求验证

**验证标准**：
- [ ] 每个需求都是可测试和可衡量的
- [ ] 需求涵盖正常、边缘和错误情况
- [ ] 用户故事提供清晰的业务价值
- [ ] 验收标准具体且无歧义
- [ ] 需求独立且不冲突
- [ ] 已解决所有用户角色和交互

**常见验证问题**：
- 这个需求可以自动测试吗？
- 预期行为是否定义清晰？
- 是否有任何假设需要明确？
- 当事情出错时会发生什么？
- 是否有任何遗漏的用户场景？

### 第四步：迭代完善

**完善流程**：
1. **与利益相关者审查**：获取关于完整性和准确性的反馈
2. **识别差距**：寻找遗漏的场景或不明确的需求
3. **澄清歧义**：解决任何模糊或冲突的需求
4. **添加遗漏细节**：包含边缘情况和错误处理
5. **验证业务价值**：确保每个需求都有明确的目的

**迭代指南**：
- 每次只做一个重点更改
- 更改后总是寻求明确批准
- 记录需求决策背后的理由
- 保持需求在适当的细节级别（不要太高，也不要太低）

## EARS 格式深入

### 基础 EARS 模式

**简单事件-响应**：
```
WHEN [用户点击提交按钮] THEN [系统] SHALL [验证表单数据]
```

**条件行为**：
```
IF [用户已认证] THEN [系统] SHALL [显示用户仪表板]
```

**复杂条件**：
```
WHEN [用户提交表单] AND [所有必填字段已完成] THEN [系统] SHALL [处理提交]
```

**错误处理**：
```
WHEN [用户提交无效数据] THEN [系统] SHALL [显示具体错误消息]
```

### 高级 EARS 模式

**基于状态的需求**：
```
WHEN [系统处于维护模式] THEN [系统] SHALL [向所有用户显示维护消息]
```

**性能需求**：
```
WHEN [用户请求数据] THEN [系统] SHALL [在 2 秒内响应]
```

**安全需求**：
```
IF [用户会话过期] THEN [系统] SHALL [重定向到登录页面]
```

## 形式良好的需求示例

### 示例 1：用户认证功能

**用户故事**：作为新用户，我想要创建一个帐户，以便我可以访问个性化功能。

**验收标准**：
1. WHEN 用户提供有效电子邮件和密码 THEN 系统 SHALL 创建新帐户
2. WHEN 用户提供现有电子邮件 THEN 系统 SHALL 显示"电子邮件已注册"错误
3. WHEN 用户提供无效电子邮件格式 THEN 系统 SHALL 显示"无效电子邮件格式"错误
4. WHEN 用户提供短于 8 个字符的密码 THEN 系统 SHALL 显示"密码太短"错误
5. WHEN 帐户创建成功 THEN 系统 SHALL 发送确认电子邮件
6. WHEN 帐户创建成功 THEN 系统 SHALL 重定向到欢迎页面

### 示例 2：数据验证功能

**用户故事**：作为用户，我想要我的输入被验证，以便我不会提交不正确的信息。

**验收标准**：
1. WHEN 用户在必填字段中输入数据 THEN 系统 SHALL 移除任何错误高亮
2. WHEN 用户提交带有空必填字段的表单 THEN 系统 SHALL 以红色高亮缺失字段
3. WHEN 用户输入无效数据格式 THEN 系统 SHALL 在字段下方显示格式要求
4. WHEN 所有验证通过 THEN 系统 SHALL 启用提交按钮
5. IF 验证失败 THEN 系统 SHALL 保持提交按钮禁用

### 示例 3：文件上传功能

**用户故事**：作为用户，我想要上传文件，以便我可以与团队共享文档。

**验收标准**：
1. WHEN 用户选择小于 10MB 的文件 THEN 系统 SHALL 接受文件上传
2. WHEN 用户选择大于 10MB 的文件 THEN 系统 SHALL 显示"文件太大"错误
3. WHEN 用户选择不支持的文件类型 THEN 系统 SHALL 显示"不支持的格式"错误
4. WHEN 上传正在进行中 THEN 系统 SHALL 显示进度指示器
5. WHEN 上传成功完成 THEN 系统 SHALL 显示成功消息
6. WHEN 上传失败 THEN 系统 SHALL 显示重试选项
7. IF 用户未认证 THEN 系统 SHALL 在上传前重定向到登录

## 常见陷阱及如何避免

### 陷阱 1：模糊的需求
**问题**："系统应该很快"
**解决方案**："WHEN 用户请求数据 THEN 系统 SHALL 在 2 秒内响应"

### 陷阱 2：需求中的实施细节
**问题**："系统应使用 Redis 进行缓存"
**解决方案**："WHEN 用户请求频繁访问的数据 THEN 系统 SHALL 返回缓存结果"

### 陷阱 3：遗漏错误情况
**问题**：仅定义快乐路径场景
**解决方案**：始终包含针对错误条件的 WHEN/IF 语句

### 陷阱 4：冲突的需求
**问题**：相互矛盾的需求
**解决方案**：一起审查所有需求并明确解决冲突

### 陷阱 5：不可测试的需求
**问题**："系统应该是用户友好的"
**解决方案**："WHEN 新用户完成入职 THEN 系统 SHALL 要求不超过 3 次点击到达主要功能"

## 质量检查清单

在移动到设计阶段之前，验证：

**完整性**：
- [ ] 所有用户角色都已识别和解决
- [ ] 正常、边缘和错误情况都已涵盖
- [ ] 所有用户交互都有定义的系统响应
- [ ] 业务规则和约束已被捕获

**清晰度**：
- [ ] 每个需求使用精确、无歧义的语言
- [ ] 避免或明确定义了技术术语
- [ ] 需求是从用户角度编写的
- [ ] 预期行为具体且可衡量

**一致性**：
- [ ] 自始至终一致使用 EARS 格式
- [ ] 术语在需求之间一致
- [ ] 需求不相互矛盾
- [ ] 类似场景处理方式相似

**可测试性**：
- [ ] 每个需求都可以通过测试验证
- [ ] 成功标准可观察且可衡量
- [ ] 需求指定了输入和预期输出
- [ ] 验收标准足够具体以指导测试创建

## 常见问题故障排除

### 问题：需求不断增长
**症状**：审查期间不断添加新需求
**解决方案**：及早设定范围边界，并将范围外的项目记录为未来迭代

### 问题：利益相关者分歧
**症状**：不同利益相关者想要冲突的功能
**解决方案**：促进讨论以了解潜在需求并找到折衷方案

### 问题：需求太技术化
**症状**：需求关注实施而非用户需求
**解决方案**：从用户角度重新构建需求，并将技术细节移至设计阶段

### 问题：需求太模糊
**症状**：无法测试或衡量的验收标准
**解决方案**：问"我们如何知道此需求已满足？"并使标准更具体

## 下一步

一旦需求完成并获批：
1. **过渡到设计阶段**：使用需求作为系统设计的基础
2. **保持可追溯性**：确保设计决策映射回具体需求
3. **保持需求更新**：如果设计揭示了差距或冲突，更新需求
4. **准备实施**：需求将指导任务分解和测试策略

需求阶段为后续一切奠定基础。花时间搞对需求可以显著节省设计和实施阶段的精力。