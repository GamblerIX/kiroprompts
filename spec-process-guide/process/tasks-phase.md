# 任务阶段文档

<!-- 导航元数据 -->
<!-- 阶段：任务 | 级别：详细指南 | 前置条件：design-phase.md -->
<!-- 相关：templates/tasks-template.md, execution/implementation-guide.md, examples/simple-feature-spec.md -->

**📍 你在这里：** [主指南](../../README.md) → [流程指南](README.md) → **任务阶段**

## 快速导航
- **🎯 开始：** [任务模板](../templates/tasks-template.md) - 即用型模板
- **📖 查看示例：** [简单功能任务](../examples/simple-feature-spec.md#tasks-document) - 完整任务示例
- **⚡ 执行任务：** [实施指南](../execution/implementation-guide.md) - 如何完成任务
- **🔄 返回开始：** [需求阶段](requirements-phase.md) - 完整工作流上下文

## 阶段导航
- **上一步：** [设计阶段](design-phase.md) - 必须首先完成
- **当前：** **任务阶段** - 将设计分解为可操作步骤
- **下一步：** [实施](../execution/implementation-guide.md) - 执行任务
- **上下文：** [流程概述](README.md) - 三阶段工作流

---

## 概述

任务阶段是规范驱动开发流程的最后阶段，将批准的设计转化为结构化的实施计划，由离散的、可操作的编码任务组成。该阶段作为规划与执行之间的桥梁，将复杂的系统设计分解为可由开发团队或 AI 编码代理增量执行的可管理步骤。

作为需求 → 设计 → 任务工作流的第三阶段，任务阶段确保所有仔细的规划和设计工作转化为系统化的、可跟踪的实施进展。

## 目的和目标

任务阶段旨在：
- 将设计组件转化为具体的编码活动
- 对任务进行排序以优化开发流程和早期验证
- 为实施创建清晰、可操作的提示
- 建立任务之间的依赖关系和构建顺序
- 通过可测试的里程碑实现增量进展
- 为系统化功能开发提供路线图

## 分步流程

### 第一步：设计分析和任务识别

**目标**：将设计分解为可实施的组件

**流程**：
1. **审查设计组件**：识别所有需要构建的系统组件
2. **映射到代码工件**：确定需要创建哪些文件、类和函数
3. **识别依赖关系**：了解在其他组件之前需要构建什么
4. **考虑测试需求**：规划与实施并行的测试创建
5. **为早期验证排序**：排序任务以快速验证核心功能

**任务识别指南**：
- 专注于具体编码活动（编写、修改、测试代码）
- 每个任务都应产生工作的、可测试的代码
- 任务应在之前工作的基础上增量构建
- 避免编码代理无法完成的任务

### 第二步：任务结构化和层级

**任务组织原则**：
1. **最大两级**：仅使用顶级任务和子任务（避免深层嵌套）
2. **逻辑分组**：将相关任务归类在有意义的类别下
3. **顺序依赖**：排序任务以便每个任务建立在之前工作基础上
4. **可测试增量**：每个任务都应产生可测试的功能

**任务层级模式**：
```markdown
- [ ] 1. [史诗/主要组件]
- [ ] 1.1 [具体实施任务]
  - [任务详情和需求引用]
- [ ] 1.2 [下一个具体任务]
  - [任务详情和需求引用]

- [ ] 2. [下一个史诗/主要组件]
- [ ] 2.1 [具体实施任务]
  - [任务详情和需求引用]
```

### 第三步：任务定义和规范

**任务规范元素**：
1. **清晰目标**：需要编写或修改的具体代码
2. **实施细节**：要创建的具体文件、组件或函数
3. **需求可追溯性**：引用正在实施的具体需求
4. **验收标准**：如何知道任务已完成
5. **测试期望**：应该编写或更新哪些测试

**任务描述模板**：
```markdown
- [ ] X.Y [任务标题]
  - [具体实施目标]
  - [要创建/修改的文件或组件]
  - [要实施的关键功能]
  - _Requirements: [需求引用]_
```

### 第四步：依赖管理和排序

**依赖考虑**：
1. **基础优先**：依赖组件之前的核心接口和数据模型
2. **自下而上方法**：高级功能之前的底层实用程序
3. **测试驱动顺序**：与实施并行或之前的测试
4. **集成点**：规划组件构建时的连接

**排序策略**：
- **核心优先**：在可选功能之前构建基本功能
- **风险优先**：尽早处理不确定或复杂的任务
- **价值优先**：实施可以快速测试的高价值功能
- **依赖驱动**：尊重组件之间的技术依赖

### 第五步：任务验证和完善

**任务质量标准**：
1. **可操作**：无需额外澄清即可由编码代理执行
2. **具体**：清楚要创建哪些文件、函数或组件
3. **可测试**：产生可测试和验证的代码
4. **增量**：基于之前的任务构建，没有大的复杂性跳跃
5. **完整**：涵盖设计中需要实施的所有方面

**验证问题**：
- 开发者能否从此任务描述立即开始编码？
- 此任务是否产生工作的、可测试的代码？
- 正在实施的需求是否已清晰识别？
- 此任务是否逻辑地建立在之前任务之上？
- 范围是否适当（不要太大，也不要太小）？

## 任务类别和模式

### 基础任务
**目的**：建立核心结构和接口
**示例**：
- 设置项目结构和依赖
- 创建核心数据模型接口
- 实施基类和实用程序
- 设置测试框架和配置

**模式**：
```markdown
- [ ] 1. 设置项目基础
- [ ] 1.1 创建项目结构和核心接口
  - 为模型、服务和实用程序设置目录结构
  - 为核心数据类型定义 TypeScript 接口
  - 创建基本配置文件
  - _Requirements: 1.1, 2.1_
```

### 数据层任务
**目的**：实施数据模型和持久化
**示例**：
- 创建带验证的数据模型类
- 实施数据访问的存储库模式
- 设置数据库连接和迁移
- 编写数据访问层测试

**模式**：
```markdown
- [ ] 2. 实施数据层
- [ ] 2.1 创建带验证的核心数据模型
  - 实施 User, Document, 和 Settings 模型类
  - 为数据完整性添加验证方法
  - 编写模型验证的单元测试
  - _Requirements: 2.1, 3.3_
```

### 业务逻辑任务
**目的**：实施核心功能逻辑
**示例**：
- 为业务操作创建服务类
- 实施工作流和处理逻辑
- 添加业务规则验证
- 编写业务逻辑集成测试

**模式**：
```markdown
- [ ] 3. 实施业务逻辑
- [ ] 3.1 创建认证服务
  - 实施用户注册和登录逻辑
  - 添加密码哈希和验证
  - 创建会话管理功能
  - 编写认证流程测试
  - _Requirements: 1.2, 4.1_
```

### API/接口任务
**目的**：创建外部接口和端点
**示例**：
- 实施 REST API 端点
- 创建请求/响应处理
- 添加输入验证和错误处理
- 编写 API 集成测试

**模式**：
```markdown
- [ ] 4. 实施 API 层
- [ ] 4.1 创建用户管理端点
  - 实施 POST /users 用于注册
  - 实施 POST /auth/login 用于认证
  - 添加请求验证和错误响应
  - 编写 API 端点测试
  - _Requirements: 1.2, 2.3_
```

### 集成任务
**目的**：连接组件和外部系统
**示例**：
- 连接依赖注入
- 实施外部 API 集成
- 连接前端到后端服务
- 添加端到端集成测试

**模式**：
```markdown
- [ ] 5. 集成和连接
- [ ] 5.1 连接认证到用户管理
  - 将认证服务连接到用户端点
  - 为受保护路由实施中间件
  - 为完整 auth 流程添加集成测试
  - _Requirements: 1.2, 4.1_
```

## 任务排序策略

### 策略 1：基础优先方法
**最适合**：新项目，具有许多相互依赖的复杂系统
**顺序**：
```markdown
1. 项目设置和核心接口
2. 数据模型和验证
3. 数据访问层
4. 业务逻辑服务
5. API 端点
6. 集成和连接
```

**优势**：
- 在构建功能之前建立坚实基础
- 减少架构更改带来的返工
- 清晰的依赖链

**劣势**：
- 可见功能前的时间较长
- 过度工程基础的风险

### 策略 2：功能切片方法
**最适合**：MVP 开发，面向用户的应用，敏捷开发
**顺序**：
```markdown
1. 核心用户注册（端到端）
2. 用户认证（端到端）
3. 用户资料管理（端到端）
4. 高级功能和优化
```

**优势**：
- 早期用户价值交付
- 更快的反馈周期
- 降低集成风险

**劣势**：
- 随着功能扩展可能需要重构
- 技术债务的潜力

### 策略 3：风险优先方法
**最适合**：具有高技术不确定性的项目，概念验证
**顺序**：
```markdown
1. 最不确定/复杂的组件
2. 外部集成和依赖
3. 核心业务逻辑
4. 用户界面和体验
5. 润色和优化
```

**优势**：
- 早期验证技术可行性
- 降低项目风险
- 告知架构决策

**劣势**：
- 可能不会早期交付用户价值
- 需要强大的技术专长

### 策略 4：混合方法
**最适合**：大多数现实世界项目
**顺序**：
```markdown
1. 最小基础（核心接口，基本设置）
2. 高风险/高价值功能切片
3. 按需扩展基础
4. 额外功能切片
5. 集成和润色
```

**优势**：
- 平衡风险管理与早期价值
- 灵活且适应性强
- 务实的方法

## 高级依赖管理策略

### 依赖类型和管理

#### 1. 技术依赖
**定义**：在构建其他组件之前必须存在的代码组件

**示例**：
- 使用它们的服务的数据库模型
- 受保护端点的认证中间件
- 功能实施前的配置设置

**管理策略**：
```markdown
- [ ] 1. 核心基础设施设置
- [ ] 1.1 创建数据库连接和配置
- [ ] 1.2 设置认证中间件框架
- [ ] 1.3 创建基础错误处理实用程序

- [ ] 2. 基础模型（依赖于 1.1）
- [ ] 2.1 创建带数据库集成的 User 模型
- [ ] 2.2 创建带数据库集成的 Session 模型

- [ ] 3. 认证服务（依赖于 1.2, 2.1, 2.2）
- [ ] 3.1 使用 User 和 Session 模型实施登录服务
```

#### 2. 逻辑依赖
**定义**：概念上建立在其他功能之上的功能

**示例**：
- 用户资料编辑需要用户注册
- 密码重置需要用户认证
- 高级搜索需要基本搜索

**管理策略**：
```markdown
- [ ] 1. 基本用户管理
- [ ] 1.1 用户注册功能
- [ ] 1.2 用户登录功能

- [ ] 2. 扩展用户功能（依赖于 1.1, 1.2）
- [ ] 2.1 用户资料编辑（需要现有用户）
- [ ] 2.2 密码重置（需要认证系统）
```

#### 3. 数据依赖
**定义**：需要特定数据或状态存在的任务

**示例**：
- 用户仪表板需要用户数据
- 报告功能需要交易数据
- 管理员功能需要用户角色

**管理策略**：
```markdown
- [ ] 1. 数据基础
- [ ] 1.1 创建用户注册和示例数据
- [ ] 1.2 创建交易记录系统

- [ ] 2. 数据依赖功能（依赖于 1.1, 1.2）
- [ ] 2.1 用户仪表板（需要来自 1.1 的用户数据）
- [ ] 2.2 交易报告（需要来自 1.2 的交易数据）
```

### 依赖可视化技术

#### 简单依赖链
```
任务 A → 任务 B → 任务 C → 任务 D
```

#### 并行依赖
```
任务 A → 任务 C
任务 B → 任务 C
```

#### 复杂依赖图
```
任务 A → 任务 C → 任务 E
任务 B → 任务 D → 任务 E
任务 A → 任务 D
```

### 处理循环依赖

**问题**：当任务似乎相互依赖时
```
用户服务需要认证服务
认证服务需要用户服务
```

**解决方案**：

1. **接口提取**：
```markdown
- [ ] 1.1 创建 IUserService 和 IAuthService 接口
- [ ] 1.2 使用 IAuthService 接口实施 UserService
- [ ] 1.3 使用 IUserService 接口实施 AuthService
- [ ] 1.4 连接依赖注入
```

2. **分层方法**：
```markdown
- [ ] 1.1 创建用户数据模型和基本 CRUD
- [ ] 1.2 使用用户 CRUD 创建认证服务
- [ ] 1.3 通过认证集成增强用户服务
```

3. **事件驱动解耦**：
```markdown
- [ ] 1.1 为用户/认证通信创建事件系统
- [ ] 1.2 用事件发布实施用户服务
- [ ] 1.3 用事件监听实施认证服务
```

## 结构良好的实施计划示例

### 示例 1：用户认证系统

```markdown
# 实施计划

- [ ] 1. 设置认证基础
- [ ] 1.1 创建项目结构和核心接口
  - 设置 auth、models 和 API 组件的目录结构
  - 为 User, Session 和 AuthRequest 类型定义 TypeScript 接口
  - 为环境变量创建基本配置
  - _Requirements: 1.1_

- [ ] 1.2 设置测试框架和数据库
  - 为单元和集成测试配置 Jest
  - 使用 Docker 配置设置测试数据库
  - 为用户表创建数据库迁移脚本
  - _Requirements: 1.1, 2.1_

- [ ] 2. 实施核心数据模型
- [ ] 2.1 创建带验证的 User 模型
  - 实施带 email、password 和 profile 字段的 User 类
  - 为电子邮件格式和密码强度添加验证方法
  - 编写 User 模型验证的单元测试
  - _Requirements: 1.2, 2.1_

- [ ] 2.2 实施 Session 模型和管理
  - 创建 Session 类用于跟踪用户会话
  - 实施会话创建、验证和过期逻辑
  - 编写会话管理的单元测试
  - _Requirements: 1.2, 4.1_

- [ ] 3. 创建认证服务
- [ ] 3.1 实施用户注册服务
  - 创建带注册方法的 UserService
  - 使用 bcrypt 添加密码哈希
  - 实施重复电子邮件检查
  - 编写注册逻辑的单元测试
  - _Requirements: 1.2_

- [ ] 3.2 实施登录和会话服务
  - 添加带密码验证的登录方法
  - 实施 JWT 令牌生成和验证
  - 创建带刷新令牌的会话管理
  - 编写登录和会话逻辑的单元测试
  - _Requirements: 1.2, 4.1_

- [ ] 4. 创建 API 端点
- [ ] 4.1 实施注册端点
  - 创建 POST /auth/register 端点
  - 添加请求验证和错误处理
  - 实施适当的 HTTP 状态代码和响应
  - 编写注册 API 的集成测试
  - _Requirements: 1.2, 2.3_

- [ ] 4.2 实施登录端点
  - 创建 POST /auth/login 端点
  - 为受保护路由添加认证中间件
  - 实施注销功能
  - 编写登录/注销 API 的集成测试
  - _Requirements: 1.2, 4.1_

- [ ] 5. 集成和安全加固
- [ ] 5.1 添加安全中间件和速率限制
  - 为 auth 端点实施速率限制
  - 添加 CORS 配置和安全标头
  - 创建用于 JWT 令牌验证的中间件
  - 编写以安全为重点的集成测试
  - _Requirements: 4.1, 2.3_

- [ ] 5.2 端到端集成测试
  - 创建完整的用户注册和登录流程测试
  - 测试错误场景和边缘情况
  - 验证安全措施和令牌处理
  - _Requirements: 1.2, 4.1_
```

### 示例 2：数据处理管道

```markdown
# 实施计划

- [ ] 1. 设置数据处理基础
- [ ] 1.1 创建核心数据处理接口
  - 定义 DataProcessor, Validator 和 Transformer 接口
  - 设置数据源和目的地的配置
  - 创建错误处理和日志实用程序
  - _Requirements: 1.1, 3.1_

- [ ] 2. 实施数据验证层
- [ ] 2.1 创建数据验证引擎
  - 实施可配置的验证规则引擎
  - 添加对必填字段、数据类型和自定义规则的支持
  - 创建带有详细错误消息的验证结果报告
  - 编写验证引擎的单元测试
  - _Requirements: 2.1, 3.2_

- [ ] 3. 构建数据转换管道
- [ ] 3.1 实施数据转换服务
  - 创建带可配置步骤的转换管道
  - 添加对数据映射、过滤和丰富的支持
  - 实施错误处理和部分失败恢复
  - 编写转换逻辑的单元测试
  - _Requirements: 2.2, 3.1_

- [ ] 4. 创建数据处理协调器
- [ ] 4.1 实施处理工作流引擎
  - 创建协调验证和转换的协调器
  - 添加对批处理和流处理模式的支持
  - 实施进度跟踪和状态报告
  - 编写完整处理工作流的集成测试
  - _Requirements: 1.1, 2.1, 2.2_
```

### 示例 3：电子商务产品管理系统

此示例展示了复杂的依赖管理和多种排序策略：

```markdown
# 实施计划

- [ ] 1. 基础和核心基础设施
- [ ] 1.1 设置项目结构和核心接口
  - 创建模型、服务、存储库和 API 层的目录结构
  - 定义 Product, Category, Inventory 和 Order 类型的 TypeScript 接口
  - 设置数据库、缓存和外部服务的配置管理
  - 配置支持单元、集成和 e2e 测试的测试框架
  - _Requirements: 1.1, 1.2_

- [ ] 1.2 创建数据库模式和迁移
  - 设计并实施产品、类别和库存的数据库模式
  - 创建初始表创建的迁移脚本
  - 设置数据库连接池和事务管理
  - 编写常见操作的数据库实用函数
  - _Requirements: 2.1, 2.2_

- [ ] 2. 核心数据模型和验证（依赖于 1.1, 1.2）
- [ ] 2.1 实施带全面验证的 Product 模型
  - 创建带 name, description, price, SKU 和 metadata 字段的 Product 类
  - 添加必填字段、价格范围和 SKU 唯一性的验证
  - 实施产品分类和标记功能
  - 编写涵盖所有验证场景的全面单元测试
  - _Requirements: 2.1, 2.3, 3.1_

- [ ] 2.2 实施带层级结构的 Category 模型
  - 创建支持父子关系的 Category 类
  - 添加类别层级深度和循环引用的验证
  - 实施类别路径生成和面包屑功能
  - 编写层级操作和边缘情况的单元测试
  - _Requirements: 2.1, 3.2_

- [ ] 2.3 实施带库存跟踪的 Inventory 模型
  - 实施带库存水平、预订和阈值的 Inventory 类
  - 添加库存操作和负库存防止的验证
  - 创建库存调整日志和审计跟踪功能
  - 编写库存操作和并发访问场景的单元测试
  - _Requirements: 2.2, 4.1_

- [ ] 3. 数据访问的存储库层（依赖于 2.1, 2.2, 2.3）
- [ ] 3.1 实施带高级查询的 Product 存储库
  - 创建带 CRUD 操作和复杂查询的 ProductRepository
  - 添加按类别、价格范围和可用性过滤的支持
  - 实施产品名称和描述的全文搜索功能
  - 编写所有存储库操作的集成测试
  - _Requirements: 3.1, 3.3_

- [ ] 3.2 实施带层级操作的 Category 存储库
  - 创建带树遍历和操作方法的 CategoryRepository
  - 添加查找所有后代、祖先和兄弟的支持
  - 实施类别重新排序和层级重组
  - 编写层级操作的集成测试
  - _Requirements: 3.2_

- [ ] 3.3 实施带并发处理的 Inventory 存储库
  - 实施带原子库存操作的 InventoryRepository
  - 添加对批量库存更新和预订的支持
  - 创建库存历史跟踪和报告查询
  - 编写包含并发访问场景的集成测试
  - _Requirements: 4.1, 4.2_

- [ ] 4. 业务逻辑服务（依赖于 3.1, 3.2, 3.3）
- [ ] 4.1 实施 Product 管理服务
  - 创建带产品生命周期业务逻辑的 ProductService
  - 添加对产品创建、更新和软删除的支持
  - 实施产品审批工作流和状态管理
  - 编写所有业务逻辑场景的单元测试
  - _Requirements: 2.1, 2.3, 5.1_

- [ ] 4.2 创建 Inventory 管理服务
  - 实施带库存分配和预订逻辑的 InventoryService
  - 添加对自动再订货点通知的支持
  - 创建带审批流程的库存调整工作流
  - 编写库存业务规则的单元测试
  - _Requirements: 4.1, 4.2, 5.2_

- [ ] 4.3 实施 Category 管理服务
  - 创建带类别层级管理的 CategoryService
  - 添加对类别合并、拆分和重组的支持
  - 实施基于类别的产品分配和批量操作
  - 编写类别管理工作流的单元测试
  - _Requirements: 3.2, 5.1_

- [ ] 5. API 层和外部接口（依赖于 4.1, 4.2, 4.3）
- [ ] 5.1 创建 Product API 端点
  - 实施产品 CRUD 操作的 REST 端点
  - 添加对产品搜索、过滤和分页的支持
  - 创建产品图像上传和管理端点
  - 编写 API 集成测试和文档
  - _Requirements: 6.1, 6.2_

- [ ] 5.2 实施 Inventory API 端点
  - 创建库存查询和更新的 REST 端点
  - 添加对库存预订和释放操作的支持
  - 实施库存报告和分析端点
  - 编写带适当错误处理的 API 集成测试
  - _Requirements: 6.1, 4.2_

- [ ] 5.3 创建 Category API 端点
  - 实施类别管理的 REST 端点
  - 添加对类别树检索和操作的支持
  - 创建基于类别的产品列表端点
  - 编写层级操作的 API 集成测试
  - _Requirements: 6.1, 3.2_

- [ ] 6. 高级功能和集成（依赖于 5.1, 5.2, 5.3）
- [ ] 6.1 实施产品搜索和推荐引擎
  - 创建带 Elasticsearch 集成的搜索服务
  - 添加对分面搜索、自动完成和拼写错误容忍的支持
  - 实施基于类别和流行度的基本推荐算法
  - 编写搜索功能的集成测试
  - _Requirements: 3.3, 7.1_

- [ ] 6.2 创建与外部系统的库存同步
  - 实施与仓库管理系统同步库存的服务
  - 添加通过 webhook 支持实时库存更新
  - 创建库存差异的冲突解决
  - 编写带模拟外部系统的集成测试
  - _Requirements: 4.3, 7.2_

- [ ] 6.3 实施性能优化的缓存层
  - 为频繁访问的产品和类别数据添加 Redis 缓存
  - 实施数据一致性的缓存失效策略
  - 为流行产品创建缓存预热流程
  - 编写性能测试以验证缓存有效性
  - _Requirements: 8.1, 8.2_

- [ ] 7. 端到端集成和测试（依赖于 6.1, 6.2, 6.3）
- [ ] 7.1 创建全面的端到端测试场景
  - 编写完整产品生命周期工作流的 e2e 测试
  - 测试包括边缘情况的库存管理场景
  - 验证类别管理和产品分配流程
  - 创建高负载场景的性能测试
  - _Requirements: 5.1, 5.2, 6.1, 6.2_

- [ ] 7.2 实施监控和可观测性
  - 添加应用程序指标和健康检查端点
  - 为所有业务操作实施结构化日志记录
  - 为关键库存和系统事件创建警报
  - 编写监控和警报功能的测试
  - _Requirements: 8.3, 8.4_
```

**此示例的关键特征**：

1. **清晰的依赖链**：每个主要部分都建立在以前的工作之上
2. **并行开发机会**：任务 2.1, 2.2, 2.3 可以在 1.x 完成后同时进行
3. **风险管理**：核心功能（模型、存储库）先于高级功能
4. **增量价值**：每个完成的部分都提供可工作的、可测试的功能
5. **全面测试**：贯穿始终的单元、集成和 e2e 测试
6. **现实世界复杂性**：处理并发、外部集成和性能问题

## 任务编写最佳实践

### 编写有效的任务描述

**好的任务示例**：
```markdown
- [ ] 2.1 创建带验证的 User 模型
  - 实施带 email, password, name 和 createdAt 字段的 User 类
  - 为电子邮件格式 (RFC 5322) 和密码强度（8+ 字符，混合大小写，数字）添加验证方法
  - 创建涵盖有效/无效电子邮件格式和密码要求的单元测试
  - _Requirements: 1.2, 2.1_
```

**糟糕的任务示例**：
```markdown
- [ ] 2.1 构建用户东西
  - 让用户东西工作
  - 添加一些验证
  - _Requirements: 1.2_
```

### 任务范围指南

**适当的任务范围**：
- 可以在 1-4 小时的专注工作中完成
- 产生工作的、可测试的代码
- 具有明确的完成标准
- 增量地建立在以前的任务之上

**太大**：
```markdown
- [ ] 1.1 实施完整的用户管理系统
```

**太小**：
```markdown
- [ ] 1.1 在第 42 行添加分号
```

**刚刚好**：
```markdown
- [ ] 1.1 创建带验证方法的 User 模型
```

### 需求可追溯性

**始终包含**：
- 引用正在实施的具体需求
- 任务与用户价值之间的清晰联系
- 测试和验证的可追溯性

**示例**：
```markdown
- [ ] 3.2 实施密码重置功能
  - 创建密码重置请求端点
  - 添加重置令牌的电子邮件发送
  - 实施安全令牌验证
  - _Requirements: 1.3, 4.2_
```

## 常见任务规划陷阱

### 陷阱 1：任务太抽象
**问题**："实施用户管理"
**解决方案**："创建带电子邮件验证和密码哈希的 User 模型"

### 陷阱 2：缺失依赖
**问题**：由于未构建先决条件而无法完成的任务
**解决方案**：排序任务以便每个任务建立在已完成工作之上

### 陷阱 3：非编码任务
**问题**："部署到生产环境"，"获取用户反馈"
**解决方案**：仅专注于编码、测试和实施活动

### 陷阱 4：单体任务
**问题**：试图一次实施整个功能的任务
**解决方案**：分解为更小的增量步骤

### 陷阱 5：缺失测试任务
**问题**：只有实施任务而没有相应的测试
**解决方案**：将测试创建作为每个实施任务的一部分

## 质量检查清单

在最终确定任务列表之前，验证：

**完整性**：
- [ ] 所有设计组件都被实施任务覆盖
- [ ] 所有需求都被一个或多个任务解决
- [ ] 包含所有主要功能的测试任务
- [ ] 集成任务连接所有组件

**清晰度**：
- [ ] 每个任务都有清晰、具体的目标
- [ ] 任务描述指定要创建的文件/组件
- [ ] 每个任务包含需求引用
- [ ] 完成标准是隐式或显式的

**排序**：
- [ ] 任务排序尊重依赖关系
- [ ] 早期任务为后续工作建立基础
- [ ] 核心功能在可选功能之前实施
- [ ] 集成任务在组件实施之后

**可行性**：
- [ ] 每个任务的范围适合实施
- [ ] 任务可以由编码代理完成
- [ ] 没有任务需要外部依赖或手动流程
- [ ] 任务复杂性逐渐增加

## 任务规划问题故障排除

### 问题：任务太模糊
**症状**：开发者无法根据任务描述开始编码
**解决方案**：添加更具体的实施细节和文件/组件名称

### 问题：任务依赖不明确
**症状**：由于缺少先决条件，任务无法完成
**解决方案**：审查任务顺序并添加遗漏的基础任务

### 问题：任务不映射到需求
**症状**：难以将任务追溯回用户价值
**解决方案**：添加需求引用并验证覆盖率

### 问题：任务列表令人不知所措
**症状**：任务太多，优先级不明确
**解决方案**：将相关任务分组并首先专注于核心功能

## 任务执行指导

### 准备实施

在开始执行任务之前，确保你拥有：

**上下文准备**：
- [ ] 需求文档可访问并已理解
- [ ] 设计文档已审查并内化
- [ ] 开发环境已设置并测试
- [ ] 测试框架已配置并准备就绪
- [ ] 版本控制系统已初始化

**任务选择策略**：
1. **从基础任务开始**：始终从设置和核心接口任务开始
2. **遵循依赖关系**：不要跳到依赖于未完成工作的任务
3. **一次一项任务**：在移动到下一个任务之前完全专注于单个任务
4. **进行前验证**：确保每个任务完全完成并测试

### 分步任务执行流程

#### 阶段 1：任务分析
**在开始任何任务之前**：
1. **彻底阅读任务详情**：确切了解需要实施什么
2. **审查需求引用**：了解正在交付的用户价值
3. **检查依赖关系**：确保所有先决任务已完成
4. **规划实施方法**：决定具体的技术方法
5. **识别成功标准**：知道你将如何验证完成

#### 阶段 2：实施
**在任务执行期间**：
1. **更新任务状态**：在开始前将任务标记为"进行中"
2. **首先创建测试**（如适用）：编写定义成功的失败测试
3. **增量实施**：逐步构建功能
4. **持续测试**：在构建时验证每一块
5. **边做边记录**：以内联方式添加注释和文档

#### 阶段 3：验证和完成
**在标记任务完成之前**：
1. **运行所有测试**：确保新旧测试通过
2. **对照需求审查**：验证任务交付了所需的功能
3. **检查集成**：确保新代码与现有组件协同工作
4. **代码质量审查**：检查可维护性和最佳实践
5. **更新任务状态**：仅在完全验证后标记为完成

### 任务执行最佳实践

#### 与 AI 编码代理合作

**用于任务执行的有效提示**：
```
我需要实施规范中的任务 [X.Y]。这是上下文：

需求：[引用具体需求]
设计上下文：[影响此任务的关键设计决策]
任务详情：[复制任务描述和详情]
依赖关系：[这建立在哪些之前的任务上]

请按照指定的方法实施此任务并包含适当的测试。
```

**迭代开发方法**：
1. **从简单开始**：首先实施基本功能
2. **逐渐增加复杂性**：增量构建功能
3. **测试每个添加**：在继续之前验证每个更改
4. **需要时重构**：边做边提高代码质量

#### 管理任务依赖

**依赖验证检查清单**：
- [ ] 所有先决任务标记为完成
- [ ] 所需的接口和类型可用
- [ ] 必要的配置到位
- [ ] 测试基础设施准备就绪

**处理受阻任务**：
1. **识别缺失的依赖**：具体是什么阻碍了进度？
2. **检查任务顺序**：任务排序正确吗？
3. **创建缺失基础**：如果需要，实施最小先决条件
4. **更新任务计划**：如果错过依赖，调整顺序

### 执行期间的质量保证

#### 每个任务的测试策略

**单元测试**：
- 为单个函数和方法编写测试
- 测试快乐路径和错误条件
- 争取新功能的高代码覆盖率
- 使用解释行为的描述性测试名称

**集成测试**：
- 测试新组件如何与现有代码工作
- 验证组件之间的数据流
- 测试跨组件边界的错误处理
- 验证配置和设置工作正常

**验证测试**：
- 对照原始需求测试
- 验证面向用户的功能按预期工作
- 测试边缘情况和边界条件
- 验证性能达到预期

#### 代码质量标准

**实施期间**：
- 遵循一致的编码风格和惯例
- 为复杂逻辑添加有意义的注释
- 使用描述性变量和函数名称
- 保持函数专注和单一用途
- 恰当处理错误

**任务完成前**：
- 移除调试代码和控制台日志
- 确保适当的错误处理到位
- 验证未引入安全漏洞
- 检查性能影响
- 验证满足无障碍需求

### 常见执行问题故障排除

#### 问题：任务需求不明确
**症状**：无法确定确切要实施什么
**解决方案**：
- 审查原始需求文档以获取上下文
- 检查设计文档以获取实施指导
- 查看相关任务以寻找模式和一致性
- 将任务分解为更小、更清晰的子步骤

#### 问题：缺失依赖
**症状**：由于缺少先决条件无法完成任务
**解决方案**：
- 审查之前的任务以确保它们真正完成
- 识别解除阻塞所需的最小实施
- 考虑是否需要调整任务顺序
- 必时实施临时存根

#### 问题：测试失败
**症状**：新旧测试在实施期间中断
**解决方案**：
- 在修复之前理解为何测试失败
- 确保新功能不破坏现有行为
- 如果需求合理更改，更新测试
- 添加新测试以覆盖发现的边缘情况

#### 问题：任务范围蔓延
**症状**：实施变得比预期大得多
**解决方案**：
- 审查原始任务范围并坚持它
- 识别可以推迟到后续任务的内容
- 将大任务分解为更小、可管理的块
- 首先专注于最小可行实施

### 进度跟踪和沟通

#### 任务状态管理

**状态定义**：
- **未开始**：任务尚未开始
- **进行中**：积极致力于实施
- **受阻**：由于依赖或问题无法继续
- **审查**：实施完成，等待验证
- **完成**：完全实施、测试并验证

**状态更新指南**：
- 开始任务工作时更新状态
- 当任务受阻或延迟时添加评论
- 仅当所有验收标准满足时标记完成
- 包含关于实施决策的简短说明

#### 执行期间的文档

**实施说明**：
- 记录实施期间做出的关键技术决策
- 记录与原始任务计划的任何偏差
- 注意遇到的任何问题及其解决方法
- 如果实施揭示差距，更新设计文档

**知识转移**：
- 编写解释更改的清晰提交消息
- 为复杂逻辑添加内联文档
- 用新的设置或使用说明更新 README 文件
- 为新功能创建示例或演示

### 适应流程

#### 为不同项目类型定制

**小型项目**：
- 为了效率合并相关任务
- 首先专注于基本功能
- 使用更简单的测试策略
- 优先考虑可工作的软件而非大量文档

**大型项目**：
- 保持严格的任务边界
- 在每一步实施全面测试
- 专注于可维护性和可扩展性
- 彻底记录架构决策

**团队项目**：
- 协调任务分配以避免冲突
- 建立代码审查流程
- 在团队中使用一致的编码标准
- 定期沟通进度和阻碍

#### 处理实施挑战

**当任务花费比预期更长的时间**：
1. 评估范围是否超出原始意图
2. 识别是否需要额外的子任务
3. 考虑任务是否应拆分为更小的部分
4. 根据经验更新剩余任务的估算

**实施期间需求变更**：
1. 停止当前工作并评估影响
2. 首先更新需求和设计文档
3. 修改实施计划中受影响的任务
4. 向利益相关者传达变更
5. 带着更新的上下文恢复实施

**当出现技术阻碍时**：
1. 记录具体技术挑战
2. 研究潜在解决方案和替代方案
3. 考虑设计是否需要调整
4. 实施最小可行解决方案以保持进度
5. 如果需要，在后续任务中规划优化

## 与规范驱动开发工作流的集成

### 连接到先前阶段

**从需求阶段**：
- 每个任务应追溯回具体需求
- 每个实施任务的用户价值应清晰
- 验收标准通知任务完成验证

**从设计阶段**：
- 任务结构遵循架构决策
- 实施方法与设计模式一致
- 组件边界尊重设计接口

### 对早期阶段的反馈

**当实施揭示问题时**：
- 如果架构需要调整，更新设计文档
- 如果被误解，澄清需求
- 如果错过依赖，修改任务计划

**持续改进**：
- 记录实施期间的经验教训
- 根据执行经验更新任务规划流程
- 提高未来项目的估算准确性

## 下一步

一旦任务完成并获批：
1. **开始实施**：使用上述指导按顺序开始执行任务
2. **跟踪进度**：随着工作完成更新任务状态
3. **保持质量**：全程遵循测试和验证实践
4. **保持灵活**：如果实施揭示问题，调整任务
5. **对照需求验证**：确保完成的任务满足原始需求
6. **记录经验**：捕获对未来规范驱动开发的见解

任务阶段提供了系统化实施的路线图，将复杂设计分解为导致成功功能交付的可管理、可操作步骤。通过适当的执行指导，团队可以在整个实施过程中保持质量和动力。